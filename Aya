-- Auto collect + drop (real drop) with fast remote click (respects server limits)
-- Supports manual target name via getgenv().UseManualTarget / getgenv().TargetName

getgenv().Config = {
    ["MaxTools"] = 35,
    ["ClickDelayMin"] = 0.05,   -- giảm delay để click nhanh hơn (nhưng không 0)
    ["ClickDelayMax"] = 0.12,
    ["AntiAfkInterval"] = 0.5,
    ["LoopDelay"] = 1.2,        -- lặp nhanh hơn nhưng vẫn có pause giữa các vòng
    ["StoppedVelocityThreshold"] = 1,
    ["DropDistance"] = 7,       -- khoảng cách đứng cách người chơi khi drop
    ["ClickRange"] = 1000       -- tối đa tìm target, thực tế sẽ dùng effRange từ ClickDetector
}

-- === MANUAL TARGET SETTINGS ===
getgenv().UseManualTarget = true
getgenv().TargetName = "YoutubeHuyGamer"

repeat task.wait() until game:IsLoaded()
Players = game:GetService("Players")
LocalPlayer = Players.LocalPlayer
repeat task.wait() until LocalPlayer and LocalPlayer:FindFirstChild("Backpack") and LocalPlayer:FindFirstChild("PlayerGui")

-- Anti-AFK
LocalPlayer.Idled:Connect(function()
    vu = game:GetService("VirtualUser")
    pcall(function()
        vu:CaptureController()
        vu:ClickButton2(Vector2.new())
    end)
end)

-- Create DropLog
if not workspace:FindFirstChild("DropLog") then
    Instance.new("Folder", workspace).Name = "DropLog"
end

-- UI Tool Counter
if not LocalPlayer.PlayerGui:FindFirstChild("ToolCounterGui") then
    gui = Instance.new("ScreenGui", LocalPlayer.PlayerGui)
    gui.Name = "ToolCounterGui"
    gui.ResetOnSpawn = false

    label = Instance.new("TextLabel", gui)
    label.Name = "CountLabel"
    label.Size = UDim2.new(0, 220, 0, 50)
    label.Position = UDim2.new(0.5, -110, 0.05, 0)
    label.BackgroundTransparency = 1
    label.TextScaled = true
    label.Font = Enum.Font.GothamBold
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextStrokeTransparency = 0.5
    label.Text = "Tools: 0"
end

-- Update Tool Count
task.spawn(function()
    while task.wait(0.5) do
        if LocalPlayer:FindFirstChild("Backpack") then
            count = 0
            for _, t in ipairs(LocalPlayer.Backpack:GetChildren()) do
                if t:IsA("Tool") then count += 1 end
            end
            gui = LocalPlayer.PlayerGui:FindFirstChild("ToolCounterGui")
            if gui and gui:FindFirstChild("CountLabel") then
                gui.CountLabel.Text = "Tools: " .. count
                gui.CountLabel.TextColor3 = (count >= getgenv().Config["MaxTools"])
                    and Color3.fromRGB(255,100,100) or Color3.new(1,1,1)
            end
        end
    end
end)

-- Utils
function isAlive()
    char = LocalPlayer.Character
    return char and char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0
end

function ensureAlive()
    if not isAlive() then
        LocalPlayer.CharacterAdded:Wait()
        task.wait(1)
    end
end

function antiAfk()
    char = LocalPlayer.Character
    if char and char:FindFirstChild("Humanoid") then
        char.Humanoid.Jump = true
        task.wait(getgenv().Config["AntiAfkInterval"])
        char.Humanoid.Jump = false
    end
end

function findNearestStoppedPlayer(range)
    range = range or 200
    myChar = LocalPlayer.Character
    if not (myChar and myChar:FindFirstChild("HumanoidRootPart")) then return end
    myPos = myChar.HumanoidRootPart.Position
    best, bestDist = nil, nil
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            root, hum = pl.Character.HumanoidRootPart, pl.Character.Humanoid
            if hum.Health > 0 and root.Velocity.Magnitude <= getgenv().Config["StoppedVelocityThreshold"] then
                dist = (root.Position - myPos).Magnitude
                if dist <= range and (not bestDist or dist < bestDist) then
                    best, bestDist = pl, dist
                end
            end
        end
    end
    return best
end

function findPlayerByName(name)
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl.Name == name then return pl end
    end
end

-- === DROP THẬT ===
function dropAllTools()
    backpack = LocalPlayer.Backpack
    char = LocalPlayer.Character
    if not (backpack and char and char:FindFirstChild("Humanoid")) then return end
    humanoid = char.Humanoid
    vim = game:GetService("VirtualInputManager")

    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            humanoid:EquipTool(tool)
            task.wait(0.12)
            vim:SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)
            task.wait(0.04)
            vim:SendKeyEvent(false, Enum.KeyCode.Backspace, false, game)
            task.wait(0.08)
        end
    end
end

function logDropRecipient(player)
    folder = workspace:FindFirstChild("DropLog")
    sv = Instance.new("StringValue")
    sv.Name = os.time() .. "_" .. (player and player.Name or "Unknown")
    sv.Value = (player and player.Name or "Unknown") .. " | Pos: " ..
        tostring(player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position) ..
        " | Time: " .. os.date("%Y-%m-%d %H:%M:%S")
    sv.Parent = folder
end

-- Safe helper: get effective MaxActivationDistance if accessible
function getEffectiveRange(clickDet)
    if not clickDet then return 0 end
    local ok, val = pcall(function() return clickDet.MaxActivationDistance end)
    if ok and type(val) == "number" then
        return val
    end
    -- fallback small value if not readable
    return 0
end

-- Fast click but respecting ClickDetector.MaxActivationDistance
function fastCollectTargets(targets)
    if not targets or #targets == 0 then return end
    char = LocalPlayer.Character
    if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
    rootPos = char.HumanoidRootPart.Position

    -- sort by distance asc
    table.sort(targets, function(a,b)
        return (a.Position - rootPos).Magnitude < (b.Position - rootPos).Magnitude
    end)

    for _, obj in ipairs(targets) do
        if obj and obj:FindFirstChild("ClickDetector") then
            local effRange = getEffectiveRange(obj.ClickDetector)
            local dist = (obj.Position - rootPos).Magnitude
            -- only click when within effective server-allowed range AND within config ClickRange
            if effRange > 0 then
                if dist <= math.min(effRange, getgenv().Config["ClickRange"]) then
                    pcall(function() fireclickdetector(obj.ClickDetector) end)
                    task.wait(math.random() * (getgenv().Config["ClickDelayMax"] - getgenv().Config["ClickDelayMin"]) + getgenv().Config["ClickDelayMin"])
                end
            else
                -- if can't read effRange, fallback to conservative: click only if reasonably close
                if dist <= math.min(60, getgenv().Config["ClickRange"]) then
                    pcall(function() fireclickdetector(obj.ClickDetector) end)
                    task.wait(math.random() * (getgenv().Config["ClickDelayMax"] - getgenv().Config["ClickDelayMin"]) + getgenv().Config["ClickDelayMin"])
                end
            end
        end
    end
end

-- Main Loop
task.spawn(function()
    RandomGen = Random.new()
    while task.wait(getgenv().Config["LoopDelay"]) do
        ensureAlive()
        backpack = LocalPlayer.Backpack
        count = 0
        for _, t in ipairs(backpack:GetChildren()) do if t:IsA("Tool") then count += 1 end end

        if count >= getgenv().Config["MaxTools"] then
            recipient = nil
            if getgenv().UseManualTarget then
                recipient = findPlayerByName(getgenv().TargetName)
            end
            if not recipient then
                recipient = findNearestStoppedPlayer(200)
            end

            if recipient and recipient.Character and recipient.Character:FindFirstChild("HumanoidRootPart") then
                logDropRecipient(recipient)
                -- drop right where you are (no teleport)
                dropAllTools()
            else
                dropAllTools()
            end
        else
            -- Collect barrels/crates from workspace
            barrels = workspace:FindFirstChild("Barrels")
            if barrels then
                targets = {}
                if barrels:FindFirstChild("Barrels") then
                    for _, obj in pairs(barrels.Barrels:GetChildren()) do
                        if obj:IsA("BasePart") and obj:FindFirstChild("ClickDetector") then
                            table.insert(targets, obj)
                        end
                    end
                end
                if barrels:FindFirstChild("Crates") then
                    for _, obj in pairs(barrels.Crates:GetChildren()) do
                        if obj:IsA("BasePart") and obj:FindFirstChild("ClickDetector") then
                            table.insert(targets, obj)
                        end
                    end
                end

                -- Fast collect but respecting server activation distance
                fastCollectTargets(targets)

                -- small anti-afk and break so main loop reevaluates tool count
                antiAfk()
            end
        end
    end
end)
